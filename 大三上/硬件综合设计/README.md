## 重庆大学计算机学院大三上专业必修《硬件综合设计》

## MIPS SOC CPU

以[计算机组成原理实验四](https://github.com/lvyufeng/step_into_mips/tree/lab_4)为框架，在5级流水线CPU的基础上，将10条简单指令扩展为57条指令，包括算数运算指令、逻辑运算指令、移位指令、分支跳转指令、数据移动指令、访存指令等52条基础指令，以及自陷指令、特权指令等5条特殊指令。详情见“龙芯杯”参考文档[《A03_“系统能力培养大赛”MIPS指令系统规范_v1.01》](https://github.com/CQU-CS-LABs/CO-lab-material-CQU/blob/2022/ref_doc/A03_“系统能力培养大赛”MIPS指令系统规范_v1.01.pdf)。

本次设计流程如下：基于lab4的数据通路，先添加完整52条基础指令，并进行funcTest independent测试确保52条扩展指令无误。然后添加完5条特殊指令后，进行SRAM接口的SOC封装。最后仿真通过89个SRAM功能测试点并上板演示。

总体设计思路如图所示，实现了连接SRAM接口的SoC系统，instr_ram与data_ram两个存储部件通过SRAM接口与CPU连接，从而可以上板运行程序，成为真正的片上系统。对于CPU核的设计分为两个主要部分，即控制模块controller和数据通路模块datapath。controller模块负责译码，输出datapath所需的控制信号，控制运算器alu以及整个CPU的运行。datapath模块负责连接CPU底层各部件的各个输入输出接口，包括取指、译码、执行、访存、写回五个阶段。其中比较重要的是冒险模块和异常处理模块，冒险模块负责处理数据冒险和控制冒险，用数据前推和阻塞解决相关的冒险；异常处理模块负责判断处理异常，即将取指、译码、执行、访存阶段发生的异常统一进行标记，在访存阶段进行处理，相应的CP0寄存器也放在了流水线的访存阶段。

<img src="https://img-blog.csdnimg.cn/994c9e1fb03b482785539f5fb7cad641.png?#pic_center" width=50%></img>

### 52条基础指令

#### 1. 算数运算指令：
`ADD、ADDU、ADDI、ADDIU、SUB、SUBU、SLT、SLTU、SLTI、SLTIU、MULT、MULTU、DIV、DIVU`

其中乘法使用Verilog中的乘号 `*`，除法采用试商法需要多周期执行。因此除 `DIV、DIVU` 外，其余指令均可复用lab4中的数据通路与冒险，只需在maindec和aludec中增加控制信号译码，然后增加alu中相应计算即可。

由于除法多周期完成需要引入时钟信号，因此将其独立于alu之外，单独使用DIV模块完成。在除法运算的过程中，模块的输出信号ready_o置0，表示除法还未结束，hazard模块收到该信号后将前3级流水线均阻塞，等到除法运算结束后再恢复运算。

#### 2. 逻辑运算指令
`AND、OR、XOR、NOR、ANDI、ORI、XORI、LUI`

前4条为普通逻辑运算，直接修改译码和alu后复用lab4即可。后4条立即数逻辑运算需要在ID阶段进行立即数无符号扩展，因为算数运算指令中的立即数扩展为有符号扩展，因此需要修改立即数扩展模块，根据运算类型进行扩展。其他改动同前4条。

#### 3. 移位指令
`SLL、SRL、SLLV、SRLV、SRA、SRAV`

无论立即数移位运算还是变量移位运算，均可修改译码和alu后复用lab4。但立即数移位运算引入了sa信号(instr[10:6])，需要加入alu的输入信号。

#### 4. 分支跳转指令
`BEQ、BNE、BGEZ、BGTZ、BLEZ、BLTZ、J、JR、BLTZAL、BGEZAL、JAL、JALR`

前6条为分支指令，跳转地址是延迟槽指令的PC（即PC+4）加上立即数偏移量。提前到ID阶段判断是否跳转以解决控制冒险，数据前推解决提前判断带来的数据冒险，都已经在lab4中实现。但提前判断时需要读取寄存器的值，可能存在数据冒险，此时则需要阻塞流水线一个周期。其实还有一个问题，分支指令的跳转方向默认为不跳转，如果跳转需要清空流水线，但hazard中并没有给出该部分的清空操作。因为现实场景一般是编译器在编译指令时加入延迟槽，延迟槽中指令不影响分支判断且一定执行，因此本实验所给的测试coe中分支指令后都跟了一条NOP指令，这样就无需清空流水线。

中间2条为跳转指令，跳转地址是延迟槽指令的PC与立即数拼接或寄存器的值。因为跳转方向一定，因此不存在控制冒险。但JR指令可能存在数据冒险，此时则需要阻塞流水线一个周期。

后4条为Link指令，除了要执行转移操作，还要将延迟槽指令后的指令的PC（即PC+8）保存到寄存器中。前三条指令都是保存到31号寄存器中，JALR指令保存到第rd项寄存器中。BLTZAL和BGEZAL本质上是BLTZ和BGEZ结合写寄存器，JAL和JALR本质上是J和JR结合写寄存器，PC+8在ID阶段就已经算出，直接写入即可。

#### 5. 数据移动指令
`MFHI、MFLO、MTHI、MTLO`

为了避免32位通用寄存器存不下乘除法运算结果的问题，MIPS架构使用了额外的HI、LO寄存器来完成乘除法运算。实验中在regfile外又加入了hiloreg，并且增加alu的hilo输入输出信号。

#### 6. 访存指令
`LB、LBU、LH、LHU、LW、SB、SH、SW`

存取1byte/2byte/1word可以复用lab4中lw和sw的数据通路，但内存访问的最小单元是字，即4字节。因此load指令需要根据类型截取所需字节并扩展至32位，store指令也需要根据类型给出不同的写使能信号。

### 5条特殊指令
如果想要CPU正常有序地运行，除了已有的模块，还需要一定的协处理器来帮助完成其他工作。在MIPS中，将这样的协处理器称为CP0寄存器，主要用于处理中断和异常、连接MMU和TLB、控制Cache以及其他的CPU相关属性。CP0寄存器其实是一组寄存器，包含BadVAddr、Count、Status、Cause、EPC寄存器，具体功能见A03手册，更多了解可移步 [《深入浅出MIPS 三 MIPS的协处理器CP0》](https://blog.csdn.net/myxmu/article/details/10508713)。本实验设计的CP0读发生在E阶段，写发生在M阶段。

#### 中断与例外
所有例外（含中断）的入口地址统一为 0xBFC0_0380，并且IF,ID,EXE,MEM检测到的例外都放在MEM阶段进行处理。
 - IF阶段：出现PC地址未对齐例外
 - ID阶段：出现系统调用例外，包括内陷与特权指令；未实现指令例外
 - EXE阶段：出现算术溢出例外
 - MEM阶段：读写数据地址未对齐例外

#### 1. 自陷指令
`BREAK、SYSCALL`

发生断点/系统调用例外时，立即无条件地将控制权转到异常处理程序。

#### 2. 特权指令
`ERET、MTC0、MFC0`

ERET指令从中断或例外处理返回，不执行下一条指令，直接执行发生例外时的指令。

MTC0和MFC0读写CP0寄存器，本设计不支持sel字段，因此直接赋0。

### 数据通路图
![在这里插入图片描述](https://img-blog.csdnimg.cn/c176b6402c314c87b1b5e7a346f6b5b4.png#pic_center)

### 设计结果
#### Mycpu目录层次
```
├─mycpu_top.v
|   ├─defines.vh
|   ├─datapath.v
|   |   ├─adder.v
|   |   ├─addr_except.v
|   |   ├─alu.v
|   |   ├─aludec.v
|   |   ├─cp0_reg.v
|   |   ├─div.v
|   |   ├─eqcmp.v
|   |   ├─exception.v
|   |   ├─hazard.v
|   |   ├─flopr.v
|   |   ├─floprc.v
|   |   ├─flopenr.v
|   |   ├─flopenrc.v
|   |   ├─hilo_reg.v
|   |   ├─lw_select.v
|   |   ├─mux2.v
|   |   ├─mux3.v
|   |   ├─pc.v
|   |   ├─regfile.v
|   |   ├─signext.v
|   |   ├─sl2.v
|   |   └sw_select.v
|   ├─controller.v
|   |   └maindec.v
|   └mmu.v
```

#### 仿真与上板结果
<img src="https://img-blog.csdnimg.cn/6c7ba555449d48158d2c08a90c9535dd.png?#pic_center" width=90%></img>

<img src="https://img-blog.csdnimg.cn/77d5748dc11349ebaa149c1d0b8fa6b8.jpeg?#pic_center" width=40%></img>

### 添加指令

根据往年经验，现场添加的指令是MAX/MIN/MATCH之一，即判断两个寄存器内的数的大小关系并返回结果。给定说明如下：
<img src="https://img-blog.csdnimg.cn/2a744e8a22b149139f4c6175275fc9c0.png?#pic_center" width=70%></img>

添加指令时，只需要在maindec和aludec中增加该条指令的控制信号译码，然后增加alu中相应计算即可，datapath和hazard均可复用。

今年由于分批次答辩，考虑到公平性，添加指令增加了取绝对值和计前导零，后者需要在ALU中加入always语句，内置for循环计算操作数的前导零个数。

### 现场提问
（答辩时根据分工对每一位成员提问，总结一些同学被提问的问题如下）
 - Q1：乘法是如何实现的？
 - Q2：除法需要中途停止怎么办？
 - Q3：添加R型指令需要改动哪些内容？
 - Q4：分支指令的条件判断在哪个价段，为什么？
 - Q5：分支跳转指令需要保存返回地址的时候，进行了哪些改动？
 - Q6：什么是延迟槽？
 - Q7：为什么数据存储器要有en、wen两个信号？是否可以合并？——一个读使能，一个写使能，如果不要读使能会一直读数据，既不安全，又高能耗。
 - Q8：为什么所有load指令均需要读出一个word的数据？
 - Q9：两个存储器和regfile的触发边缘为什么要置为下降沿？
 - Q10：解释为何lw要写的寄存器号和下一条指令要读的寄存器号产生相关时，需要stall？
 - Q11：解释数据前推为何不需要由M阶段前推到D阶段（仅R型指令和相关情况下）？
 - Q12：解释d触发器模块rst、en、clear信号在流水线中的作用？
 - Q13：大小尾端是在哪儿处理的？如何处理的？（没碰到就答没有）
 - Q14：HILO寄存器如何实现的？靠什么触发？
 - Q15：HILO寄存器写入过程有没有数据冒险？
 - Q16：请解释一下精确异常？
 - Q17：ERET有没有延迟槽？
 - Q18：CP0仅在一种情况下可以开启写使能，请问是什么情况？
 - Q19：CP0各个寄存器存的是什么？
 - Q20：什么情况下，cause寄存器的31位会置1？
 - Q21：软中断时如何产生的？何时触发？
 - Q22：ERET的跳转地址是什么？何时执行？
 - Q23：发生异常的跳转和正常情况的跳转有什么区别？
 - Q24：如果BRANCH指令后跟了ERET，数据通路是什么？
 - Q25：SOC是如何封装的？
 - Q26：在实现过程中你们引用了些什么？
 - Q27：你们在设计过程中有什么典型的bug？

### 参考资料
[重庆大学硬件综合设计实验文档](https://co.ccslab.cn/)