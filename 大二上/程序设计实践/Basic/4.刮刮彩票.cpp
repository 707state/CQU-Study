/*刮刮彩票：
题目：“刮刮彩票”是一款网络游戏里面的一个小游戏。每次游戏玩家会拿到一张彩票，上面会有 9 个数字，
    分别为数字1到数字9，数字各不重复，并以 3×3 的“九宫格”形式排布在彩票上。在游戏开始时能看见
    一个位置上的数字，其他位置上的数字均不可见。你可以选择三个位置的数字刮开，这样玩家就能看见
    四个位置上的数字了。最后玩家再从3横、3竖、2斜共8个方向中挑选一个方向，方向上三个数字的和可
    根据下列表格进行兑奖，获得对应数额的金币。
 数字合计 获得金币 数字合计 获得金币
 6	    10,000	 16	     72
 7	    36	     17	     180
 8	    720	     18	     119
 9	    360	     19	     36
 10	    80	     20	     306
 11	    252	     21	     1,080
 12	    108	     22	     144
 13	    72	     23	     1,800
 14	    54	     24	     3,600
 15	    180		
    现在请你写出一个模拟程序，模拟玩家的游戏过程。
输入:第一部分给出一张合法的彩票，即用3行3列给出0至9的数字。0表示的是这个位置上的数字初始时就能
    看见了，而不是彩票上的数字为0。第二部给出玩家刮开的三个位置，分为三行，每行按格式 x y 给出
    玩家刮开的位置的行号和列号（题目中定义左上角的位置为第 1 行、第 1 列。）。数据保证玩家不会
    重复刮开已刮开的数字。最后一部分给出玩家选择的方向，即一个整数：1至3表示选择横向的第一行、
    第二行、第三行，4 至 6 表示纵向的第一列、第二列、第三列，7、8分别表示左上到右下的主对角线
    和右上到左下的副对角线。
输出:对于每一个刮开的操作，在一行中输出玩家能看到的数字。最后对于选择的方向，在一行中输出玩家获
    得的金币数量。
*/
#include <iostream>
#include <vector>
using namespace std;

int main(){
    vector<int> vec1(9);        //vec1表示彩票的各位置上的数

    vector<int> vec2;           //vec2下层代码需要压入元素时声明时便不要限定长度
    vec2={10000,36,720,360,80,252,108,72,54,180,72,180,119,36,306,1080,144,1800,3600};
    //vec2表示数字合计对应获得的金币数

    for(int i=0;i<9;++i){
        int m;
        cin>>m;
        vec1[i]=m;
    }

    int sum=0;                  //找到初始可以看见的数字“0”，采用所有数字叠加求差
    int tmp;                    //计数变量记“0”的下标
    for(int i=0;i<9;++i){
        if(vec1[i]==0)
            tmp=i;
        sum+=vec1[i];
    }
    int abs=45-sum;             //abs表示缺失的数字
    vec1[tmp]=abs;

    for(int j=0;j<3;j++){
        int x,y;                //x,y表示刮开位置的行列号
        cin >> x >> y;
        if(x==1){
        cout<<vec1[y-1]<<endl;
        }
        else if(x==2){
            cout<<vec1[y+2]<<endl;
        }
        else{
            cout<<vec1[y+5]<<endl;
        }
    }
    int num0,num;                    //num0表示刮开的方向数
    cin>>num0;
    switch (num0){
    case 1:
        num=vec1[0]+vec1[1]+vec1[2];
        cout<<vec2[num-6];
        break;
    case 2:
        num=vec1[3]+vec1[4]+vec1[5];    //此处num不可以再次声明
        cout<<vec2[num-6];
        break;
    case 3:
        num=vec1[6]+vec1[7]+vec1[8];
        cout<<vec2[num-6];
        break;
    case 4:
        num=vec1[0]+vec1[3]+vec1[6];
        cout<<vec2[num-6];
        break;
    case 5:
        num=vec1[1]+vec1[4]+vec1[7];
        cout<<vec2[num-6];
        break;
    case 6:
        num=vec1[2]+vec1[5]+vec1[8];
        cout<<vec2[num-6];
        break;
    case 7:
        num=vec1[0]+vec1[4]+vec1[8];
        cout<<vec2[num-6];
        break;
    case 8:
        num=vec1[2]+vec1[4]+vec1[6];
        cout<<vec2[num-6];
        break;
    }

    return 0;
}