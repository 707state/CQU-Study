/*整除光棍：
题目：这里所谓的“光棍”，说的是全部由1组成的数字，比如1、11、111、1111等。传说任何一个光棍都能被一个不以5结尾的奇数整除。比如，111111就可以被13整除。 现在，你的程序要读入一个整数x，这个整数一定是奇数并且不以5结尾。然后，经过计算，输出两个数字：第一个数字s，表示x乘以s是一个光棍，第二个数字n是这个光棍的位数。这样的解当然不是唯一的,题目要求你输出最小的解。
提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除x为止。但难点在于，s可能是个非常大的数————比如，程序输入31，那么就输出3584229390681和15，因为31乘以3584229390681的结果是111111111111111，一共15个1。
思路：本题若循规蹈矩，非常简单，但容易造成长整型过长导致溢出。因此，溯回除法的最基本思想，从高位向低位作整除，l/x放在商里，l%x继续整除，这样l一边*10+1，一边%x，永远不会过长
*/
#include <iostream>
#include<vector>
using namespace std;

//整出光棍：

int main(){
    int x;
    cin>>x;
    int l=0;                //l用来表示光棍数
    int tmp;                //tmp用来记l的长度
    bool flag=0;            //flag初值为0，开头整除为0时不补零，一旦商首位出现非零，flag赋为1，则整除为0时补零
    // while(l%x!=0){
    //     l=10*l+1;        //若用简单的while循环来实现，容易造成p过大而溢出
    // }                    
    for(int i=1;;i++){      //i不仅用来计数，还可以用来记“l=10*l+1”的次数，即l的长度
        l=10*l+1;           //l初值为0，即使x=1，也可以对其直接*10+1，而不会产出范围
        if(l>=x){
            flag=1;         //商首位出现非零，flag赋为1，后面开始补零
            cout<<l/x;      //不空格，不换行，商一位一位输出
        }
        else if(flag==1){
            cout<<0;
        }
        l%=x;               //用余数继续做除法
        tmp=i;
        if(l==0){
            break;
        }
    }
    cout<<" "<<tmp<<endl;

    return 0;
}