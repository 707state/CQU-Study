/*壕排序2：
题目：壕班学生排队取快递，要是看到前面学生手机里的零用钱比自己少就不爽，就赏给前面的人1块钱，然后跟
    他交换位置。全班所有学生都这么"壕"，容不得比自己“穷”的学生排自己前面，于是一个队伍就不停的交换，
    直到没人不爽为止。但是有时候却会出现无法排序的情况，导致某些人在那里永无休止的换位子。
输入：第一行给出正整数N，表示壕班学生人数(1<N<30000)。第二行给出N个正整数，第i个数值表示最初排在第
    i位的学生手机里的零钱数目(1≤i≤N)。相邻数值间用空格分开。所有数值都在区间[1,100000]以内。
输出：排序完成后所有学生的零钱数目，按降序排列。数值间用空格分开，末尾的数值后面不留空格。如果不能排
    序，输出字符串"unsortable!\n"。
思路：数组元素向前移-1，向后移+1。无休止的两人换位置情况原因是两人相差1，因此只要将所有元素移至开头
    （减去相应步数）后判断是否有元素值相等即可。
    可以进行壕排序的序列显然是降序且无重复元素，序列内各位的值等于移至开头后再加上相应步数得到当前
    所在位置的值（b[i]+i）
*/
#include <iostream>
#include <algorithm>
using namespace std;

int main(){
    int N;
    cin>>N;
    int a[30001]={0};
    int b[30001]={0};           //备份数组
    for(int i=0;i<N;i++){
        cin>>a[i];
        b[i]=a[i]-i;            //移到开头的值
    }
    sort(b,b+N,greater<int>());
    bool flag=1;
    for(int i=1;i<N;i++){
        if(b[i]==b[i-1]){
            flag=0;
        }
    }
    if(!flag){
        cout<<"unsortable!"<<endl;
        return 0;
    }
    //对于可以壕排序的数组，while执行复杂度太高，巧妙利用数组b输出答案
    cout<<b[0];
    for(int i=1;i<N;i++){
        cout<<" "<<b[i]+i;
    }

    return 0;
}
