/*最少交换次数II：
题目：给出一个序列，序列个数为n，可交换任意两个数，使序列升序排列，求最少交换次数。
思路：举个例子，有序列{5,8,4,2,6,1,7,3}共8个数，按升序排列之后为1,2,3,4,5,6,7,8。
    最少交换次数肯定是 与{1,2,3,4,5,6,7,8}不对应的数的个数 减去 可以形成的环的个数。
    （因为每个环的最后一个数都不用排序的，前面都排好了，最后一个自然就序），此数组有两个环，所以是5次。
hint：环指的是例如上面数组中的1,6,5三个数虽然都不在自己应该在的位置，
    但他们占据了排好序后1,6,5应该占据的位置，所以可以抽象成一个环，环内换顺序就行了。
    因为1,6,5都不在各自位置，所以需要交换2次，所以每个环可以少交换一次。
    同样3,2,4,8也是一个环，所以是7-1-1=5
下面简述搜索环的算法：用两个数组分别存储序列及其排序，通过map组成序列元素和下标的键值对，
    搜寻排序后与原序列位置不符的元素，顺着键值对找到同在一个环的元素
*/
#include <iostream>
#include <algorithm>
#include <map>
using namespace std;

int a[100],b[100];      //a用来存储序列，b用来存储排序后的递增序列
bool flag[100]={0};     //flag用来存储a与b中不在同一位置的元素

int main(){
    int N;
    cin>>N;
    map<int,int> mp;
    int circle=0;       //circle统计环的数量
    int cnt=0;          //cnt统计a与b中不在同一位置的元素数量
    for(int i=1;i<=N;i++){      //都从1开始计数
        int m;
        cin>>m;
        a[i]=m;
        b[i]=m;
        mp[a[i]]=i;
    }
    sort(b+1,b+N+1);
    for(int i=1;i<=N;i++){      //构造flag，对应元素不同的保留0，相同的赋为1
        if(a[i]==b[i]){
            flag[i]=1;
        }
        else{
            cnt++;           
        }
    }
    for(int j=1;j<=N;j++){
		if(!flag[j]){
			int tmp = j;
			while(!flag[tmp]){
				flag[tmp]=1;    //避免重复操作
				tmp=mp[b[tmp]]; //a中下标->b中元素->b中元素在a中下标->进入循环
        	}
			circle++;
		}
	}
    cout<<cnt-circle;

    return 0;
}
//因为用到了map，所以键对应的值唯一，因此序列中不能有重复数字