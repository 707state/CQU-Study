/*最少交换次数III：
题目：长度为N的数组中只有1，2，3三种值，要按升序排序，并且只能通过数值间的两两交换实现不能移位。
    比如某项竞赛的优胜者按金银铜牌排序，或者荷兰国旗问题都是该问题的实例。
    给定的一个 1,2,3 组成的数字序列，求排成升序所需的最少交换次数。
思路：因为序列中只有1,2,3三种值，因此按升序排序后可划分为3个区域，令为C1,C2,C3，分别存放1,2,3
    比较排序前后，有些数字一次交换就能达到正确区域，即Cx中的y , Cy中的x（x,y∈{1,2,3}）
    有些数字两次交换可以达到正确区域，即剩下的数字中排序前便不在正确区域的数字
*/
#include <iostream>
#include <algorithm>
using namespace std;

int a[100],b[100];      //a,b用来存储序列
int d[4][4]={0};        //d用来存储各区域内不在正确区域的数字

int main(){
    int N;
    cin>>N;
    int cnt=0;          //cnt表示不用排序数字的个数
    int c1=0;           //c1表示一次交换就能达到正确区域的数字个数
    int c2;             //c2表示两次交换才能达到正确区域的数字个数
    for(int i=1;i<=N;i++){
        int m;
        cin>>m;
        a[i]=m;
        b[i]=m;
    }
    sort(b+1,b+N+1);
    for(int i=1;i<=N;i++){
        if(a[i]==b[i]){
            cnt+=1;
        }
    }
    for(int i=1;i<=N;i++){
        if(b[i]==1){
            if(a[i]==2) d[1][2]++;  //表示在区域1中2的个数
            if(a[i]==3) d[1][3]++;
        }
        if(b[i]==2){
            if(a[i]==1) d[2][1]++;
            if(a[i]==3) d[2][3]++;
        }
        if(b[i]==3){
            if(a[i]==1) d[3][1]++;
            if(a[i]==2) d[3][2]++;
        }
    }
    while(d[1][2]!=0&&d[2][1]!=0){  //1在区域2，2在区域1，所以一次交换就能达到正确区域
        d[1][2]--;
        d[2][1]--;
        c1++;
    }
    while(d[1][3]!=0&&d[3][1]!=0){
        d[1][3]--;
        d[3][1]--;
        c1++;
    }
    while(d[2][3]!=0&&d[3][2]!=0){
        d[2][3]--;
        d[3][2]--;
        c1++;
    } 
    c2=N-cnt-2*c1;                  //*2因为c1中元素成对出现
    c2/=3;                          //c2必定是3的倍数（包括0），因此模3求环
    cout<<c1+2*c2;                  //每个环交换2次

    return 0;
}