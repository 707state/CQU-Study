/*最长递增子序列
题目：设arr[0 ... n-1]为输入数组，L(i)表示以arr[i]为结尾的最长递增子序列的长度。
    比如：输入arr[]={3, 5, 2, 8}。L(0)表示以arr[0]=3结尾的最长递增子序列的长度，L(0)=1；
    L(1)表示以arr[1]=5结尾的最长递增子序列{3，5}的长度，L(1)=2；
    L(2)表示以arr[2]=2结尾的最长递增子序列{2}的长度，L(2)=1；
    L(3)表示以arr[3]=8结尾的最长递增子序列{3，5，8}的长度，L(3)=3。
法一：递归
    L(i)可以被递归地表示为如下形式：
        L(i)=1+max(L(j))，其中0<=j<i且arr[j]<arr[i]；
    比如L(3)=1+L(1)=3。或者L(i)=1，不存在arr[j]<arr[i]的情况；比如L(2)=1，因为arr[0]和arr[1]
    的值均大于arr[2] 的值。而最终一个给定数组的 LIS 就是取值最大的max(L(i))，其中0<=i<n; 比如，
    对于数组 arr[]={3,5,2,8}而言,其 LIS 的长度为 L(3) = 3 。
    由上面的分析可知，对于给定的数组arr[]，以arr[i]结尾的最长递增子序列的长度等于子问题arr[j]的解加1，其中0<=j<i且arr[j]<arr[i]。
也就是说最长递增子序列具有最优子结构性质，可以由子问题的解得到原问题的解。

法二：动态规划
    递归存在大量的子问题被重复计算，效率极低；可以通过备忘录或者DP Table对其进行剪枝，避免子问
题的重复计算，从而提高算法的执行效率！
    首先我们可以初始化dp[]中的元素均为1，因为以数组arr[]中的任意一个元素结尾的最长递增子序列的
长度至少为1。当i=0时，我们相当于仅考虑子数组subarr[]={3}的情况，最长公共子序列的长度自然为1；
当i=1时，以arr[1]=5结尾的子数组subarr[]={3,5}的最长递增子序列为{3,5}，长度为2。但是考虑用子问
题dp[0]=1的解来得到当前问题的解dp[1]=2又该如何得到呢？
    这就要回到问题本身，arr[1]=5，只有当子问题的值arr[0]=3小于时，才可以对其自身的长度加1，而
arr[0]<arr[1]，所以dp[1]=max(dp[1]，dp[0]+1)=2；
    当i=2时，arr[2]=2<arr[1]=5且arr[2]<arr[0]，所以不更新dp[2]的值；
    当i=3时，arr[0]=3<arr[3]=8，则更新dp[3]=max(dp[3]，dp[0]+1)=2;
        arr[1]=5<arr[3]=8，则更新dp[3]=max(dp[3]，dp[1]+1)=3 ;
        arr[2]=2<arr[3]=8，则更新dp[3]=max(dp[3]，dp[2]+1)=3 ;
    dp[i]就表示以arr[i]结尾的最长递增子序列的长度，那么状态转移方程是什么呢？
其实就是一步一步总结的规律：
    if(0<=j<i&&arr[j]<arr[i]){
        dp[i]=max(dp[j]+1,dp[i]);
    }
    else if(0<=j<i&&arr[j]>arr[i]){
        dp[i]=1;
    }
*/

#include <iostream>
#include <stdlib.h>
using namespace std;

int main(){
    int n;
    cin>>n;
    int *arr= new int[n];
    int *dp=new int[n];
    for(int i=0;i<n;i++){
        int m;
        cin>>m;
        arr[i]=m;
        dp[i]=1;
    }           //构造了两个数组，接下来开始动态规划
    for(int i=0;i<n;i++){
        for(int j=0;j<i;j++){
            if(arr[j]<arr[i]){
                if(dp[j]+1>dp[i])   dp[i]=dp[j]+1;
            }
        }
    }           //动态规划结束，结果已经存入数组dp[]
    int max=1;
    for(int i=0;i<n;i++){
        if(dp[i]>max){
            max=dp[i];
        }
    }
    cout<<max<<endl;

    return 0;
}