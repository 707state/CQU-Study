/*真实的背包故事：
题目：0-1背包问题是经典的动态规划问题，这个问题大多用这样的故事开场：一个小偷溜进了一家博物馆，
	博物馆里排列着N件珍稀古董，每件古董都有重量和价值，而小偷带来的背包有重量限制W。因此，小偷
	的目的就是要选择部分古董，使其总重量不超过W且总价值最大。这故事听上去就像小偷在逛超市一样能
	轻松自如地挑选，而真实的情况是小偷提心吊胆，尤其是每拿下一件古董，随时都有触动警报的危险，
	所以小偷想尽可能少带几件古董立马跑路，但他的职业“素养”又不允许他不把背包装满。你能帮他解决
	这个困境吗？
输入：第一行中给出2个整数值N和W，其中1<N≤100表示古董的数量，1<W≤2000表示背包的重量限制。接下来
	N行数据，每行两个正整数。第i行（1≤i≤N)的整数vi和wi分别表示第i件古董的价值和重量。vi和wi的
	值均不超过2000。
输出：在一行中输出两个整数值，用空格分开。第一个整数表示装背包能获得的最大总价值，第二个整数表示
	在获得最大价值的条件下装入背包里的古董的最少数量。
输入样例1:
6 6
1 1
2 2
3 3
4 4
5 5
6 6
输出样例1:
6 1
输入样例2:
5 5
1 2
3 5
2 2
6 3
5 1
输出样例2:
11 2
思路：从C以下最重的开始取不能保证价值最大，因此还需要动态规划
*/
#include <iostream>
#include <algorithm>
using namespace std;

int main(){
	int N,C;
	cin>>N>>C;
    int W[N+1]={0};
    int V[N+1]={0};
	for(int i=1;i<=N;i++){
		cin>>V[i];
		cin>>W[i];
	}
    int dp[N+1][C+1]={{0}};
	int num[N+1][C+1]={{0}};
    for(int i=0;i<=N;i++){
        for(int j=0;j<=C;j++){
            dp[i][j]=0;
			num[i][j]=0;
        }
    }
    for(int i=1;i<=N;i++){
        for(int j=1;j<=C;j++){
            if(j>=W[i]){
                if(dp[i-1][j]>dp[i-1][j-W[i]]+V[i]){
                    dp[i][j]=dp[i-1][j];
					num[i][j]=num[i-1][j];
                }
				else if(dp[i-1][j]==dp[i-1][j-W[i]]+V[i]){
					if(num[i-1][j]<num[i-1][j-W[i]]+1){	//若两种方案价值相等，取操作少的
						dp[i][j]=dp[i-1][j];
						num[i][j]=num[i-1][j];
					}
					else{
						dp[i][j]=dp[i-1][j-W[i]]+V[i];
						num[i][j]=num[i-1][j-W[i]]+1;
					}
				}
                else{
                    dp[i][j]=dp[i-1][j-W[i]]+V[i];
					num[i][j]=num[i-1][j-W[i]]+1;
                }
            }
            else{
                dp[i][j]=dp[i-1][j];
				num[i][j]=num[i-1][j];
            }
        }
    }
    cout<<dp[N][C]<<" "<<num[N][C]<<endl;
	// for(int i=1;i<=N;i++){
	// 	for(int j=1;j<=C;j++){
	// 		cout<<dp[i][i]<<" ";
	// 	}
	// 	cout<<endl;
	// }

    return 0;
}