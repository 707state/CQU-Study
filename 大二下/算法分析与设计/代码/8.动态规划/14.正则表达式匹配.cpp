/*正则表达式匹配：
题目：给定一个字符串s和一个字符模式p，实现'.'和'*'的正则表达式匹配。其中，'.'匹配任意单个字符，'*'
    匹配零或多个前面的元素(前面字符包含在这些元素里)。匹配指的是p可以覆盖整个s，而不是部分。其中
    s可能为空且只包含a~z，p可能为空且只包含a~z、'.'、'*'。
    如：Match("aaa","aa")=false, Match("aa","a*")=true
        Match("aa",".*")=true, Match("aa","a*")=true
        Match("abcb",".*")=true（.*表示多个.）
        Match("aab","c*a*b")=true（0个c+2个a+1个b）
        Match("aaa","ab*ac*a")=true
        Match("aaa","aa.a")=false
        Match("aaa","ab*a")=false
思路：对于'.'来说，它和任意字符都匹配，可把其当做普通字符。对于'*'的分析，需要分情况讨论：
    1 在每轮匹配中，当Pattern第二个字符不是'*'时，情况简单：
        1.1 如果字符串的第一个字符和模式中的第一个字符匹配，那么在字符串和模式上都向后移动一个字
            符，然后匹配剩余字符串和模式。
        1.2 如果字符串的第一个字符和模式中的第一个字符不匹配，那么直接返回false。
    2 当Pattern第二个字符是'*'时,情况复杂：
        2.1 第一个字符不匹配（除了'.'与任意字符视作匹配），那么这时'*'只能代表匹配0次，比如"ba"
            与"a*ba"，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式。
        2.2 第一个字符匹配，那么'*'可能代表匹配0次，1次，多次，比如"ba"与"b*ba"、"aba"与"a*ba"、
            "aaaba"与"a*ba"。
            2.2.1 匹配0次时，字符串不变，模式向后移动2个字符； 
            2.2.2 匹配1次时，字符串往后移动一个字符，模式向后移动2个字符；
            2.2.3 匹配多次时，字符串往后移动一个字符，模式不变（因此后面可以继续取0/1/多次!!!）
        上述2.2.1~2.2.3取或即可
    上述思路显然可以用递归，但复杂度太高，下采用dp讲解：
        设 bool M[i][j]=Match(p1p2...pi,s1s2...sj),因为p为判断模式，因此围绕p展开讨论，则
    if(pi=='.')     M[i][j]=M[i-1][j-1]
    if(pi>='a'&&pi<='z') M[i][j]=M[i-1][j-1]&&(pi==sj)
    if(pi=='*')     匹配0次: M[i][j]=M[i-2][j]
                    匹配1次: M[i][j]=M[i-1][j]
                    匹配多次:此时p1p2...pi和s1s2...sj-1也匹配，即M[i][j-1]=1，
                        并且匹配多次的字符pi-1和sj也要匹配，即p[i-1]==s[j]||p[i-1]=='.'
                综上，M[i][j]=M[i-2][j]||M[i-1][j]||(M[i][j-1]&&(p[i-1]==s[j]||p[i-1]=='.'))
    初始条件为: 主要考虑i<2的情况，防止i-2段错误；以及j=0的情况
                    M[0][0]=1(因为p和s都为空，可以认为是匹配)
                    M[0][j>0]=0(模式为空，只能匹配空字符串)
                    M[1][0]=0(如果想用x*匹配0次也需要p.length>=2)
                    M[1][1]=(p1=='.')||(p1==s1)
                    M[1][j>1]=0
                    M[i>1][0]=(pi=='*')&&M[i-2][0]
*/
#include <iostream>
#include <vector>
using namespace std;

int main(){
    // string p=" ab*ac*a";
    string p=" aa.a";
    string s=" aaa";
    int n=p.length()-1;
    int m=s.length()-1;
    bool M[n+1][m+1];
    //初始化
    M[0][0]=1;
    M[1][0]=0;
    M[1][1]=(p[1]=='.')||(p[1]==s[1]);
    for(int j=1;j<=m;j++){
        M[0][j]=0;
        if(j>1){
            M[1][j]=0;
        }
    }
    for(int i=2;i<=n;i++){
        M[i][0]=(p[i]=='*')&&M[i-2][0];
    }
    //dp
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(p[i]=='.'){
                M[i][j]=M[i-1][j-1];
                // cout<<1<<":"<<i<<" "<<j<<" "<<M[i][j]<<endl;
            }else if(p[i]>='a'&&p[i]<='z'){
                M[i][j]=M[i-1][j-1]&&(p[i]==s[j]);
                // cout<<2<<":"<<i<<" "<<j<<" "<<M[i][j]<<endl;
            }else if(p[i]=='*'){
                M[i][j]=M[i-2][j]||M[i-1][j]||(M[i][j-1]&&(p[i-1]==s[j]||p[i-1]=='.'));
                // cout<<3<<":"<<i<<" "<<j<<" "<<M[i][j]<<endl;
            }
        }
    }
    cout<<M[n][m]<<endl;
    // for(int i=0;i<=n;i++){
    //     for(int j=0;j<=m;j++){
    //         cout<<M[i][j]<<" ";
    //     }
    //     cout<<endl;
    // }

    
    return 0;
}